# frozen_string_literal: true

RSpec.describe Destination::ScheduleRateChanges do
  subject do
    described_class.call(
      ids:,
      apply_time:,
      initial_interval:,
      initial_rate:,
      next_interval:,
      next_rate:,
      connect_fee:
    )
  end

  let!(:destinations) do
    [
      FactoryBot.create(:destination, destination1_attrs),
      FactoryBot.create(:destination, destination2_attrs),
      FactoryBot.create(:destination, destination3_attrs)
    ]
  end
  let(:destination1_attrs) { { valid_till: apply_time + 1.month } }
  let(:destination2_attrs) { { valid_till: apply_time + 1.day } }
  let(:destination3_attrs) { { valid_till: apply_time + 1.second } }

  let(:ids) { destinations.pluck(:id) }
  let(:apply_time) { 1.month.from_now.to_date }
  let(:initial_interval) { 60 }
  let(:initial_rate) { 0.1 }
  let(:next_interval) { 60 }
  let(:next_rate) { 0.2 }
  let(:connect_fee) { 0.03 }

  before do
    # not affected destinations
    FactoryBot.create_list(:destination, 3)
  end

  it 'should create DestinationNextRate for destinations' do
    # reload need cause uuid is generated by db
    destinations_attributes = destinations.map { |destination| destination.reload.attributes }

    expect { subject }.to change { Routing::DestinationNextRate.count }.by(destinations.size)

    destinations.each(&:reload)
    expect(destinations.map(&:attributes)).to eq(destinations_attributes)

    destination_next_rates = Routing::DestinationNextRate.last(destinations.size)
    expect(destination_next_rates).not_to be_empty
    destination_next_rates.each_with_index do |d_next_rate, index|
      destination = destinations[index]

      expect(d_next_rate).to have_attributes(
                               initial_interval:,
                               initial_rate:,
                               next_interval:,
                               next_rate:,
                               connect_fee:,
                               apply_time:,
                               destination_id: destination.id
                             )
    end
  end

  context 'when destinations already have destinations next rates' do
    let!(:destination_next_rates) do
      [
        *FactoryBot.create_list(:destination_next_rate, 3, destination: destinations[0]),
        FactoryBot.create(:destination_next_rate, destination: destinations[1])
      ]
    end

    before do
      # not affected destinations
      FactoryBot.create_list(:destination_next_rate, 3)
    end

    it 'should delete old DestinationNextRate for destinations' do
      destinations_attributes = destinations.map { |destination| destination.reload.attributes }

      expect { subject }.to change { Routing::DestinationNextRate.count }.by(destinations.size - destination_next_rates.size)

      destinations.each(&:reload)
      expect(destinations.map(&:attributes)).to eq(destinations_attributes)

      destination_next_rates = Routing::DestinationNextRate.last(destinations.size)
      expect(destination_next_rates).not_to be_empty
      destination_next_rates.each_with_index do |d_next_rate, index|
        destination = destinations[index]

        expect(d_next_rate).to have_attributes(
                                 initial_interval:,
                                 initial_rate:,
                                 next_interval:,
                                 next_rate:,
                                 connect_fee:,
                                 apply_time:,
                                 destination_id: destination.id
                               )
      end
    end
  end

  context 'when destinations have valid_till >= apply_time' do
    let(:destination1_attrs) { super().merge(valid_till: apply_time - 1.second) }
    let(:destination2_attrs) { super().merge(valid_till: apply_time) }

    let(:new_valid_till) { apply_time + 40.years }

    it 'should update expired destinations valid_till' do
      destination1_attributes = destinations[0].reload.attributes.symbolize_keys
      destination2_attributes = destinations[1].reload.attributes.symbolize_keys
      destination3_attributes = destinations[2].reload.attributes.symbolize_keys

      expect { subject }.to change { Routing::DestinationNextRate.count }.by(destinations.size)

      expect(destinations[0].reload).to have_attributes(
                                         **destination1_attributes,
                                         valid_till: new_valid_till
                                       )
      expect(destinations[1].reload).to have_attributes(
                                         **destination2_attributes,
                                         valid_till: new_valid_till
                                       )
      expect(destinations[2].reload).to have_attributes(**destination3_attributes)

      destination_next_rates = Routing::DestinationNextRate.last(destinations.size)
      expect(destination_next_rates).not_to be_empty
      destination_next_rates.each_with_index do |d_next_rate, index|
        destination = destinations[index]

        expect(d_next_rate).to have_attributes(
                                 initial_interval:,
                                 initial_rate:,
                                 next_interval:,
                                 next_rate:,
                                 connect_fee:,
                                 apply_time:,
                                 destination_id: destination.id
                               )
      end
    end
  end

  context 'when apply_time is in the past' do
    let(:apply_time) { 1.month.ago.to_date }

    it 'should raise an error' do
      expect { subject }.to raise_error(described_class::Error, 'Apply time must be in the future')
    end
  end

  context 'when ids=[]' do
    let(:ids) { [] }

    it 'should raise an error' do
      expect { subject }.to raise_error(described_class::Error, "Ids can't be blank")
    end
  end
end
